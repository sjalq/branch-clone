#!/usr/bin/env bash

set -e

VERSION="2.0.0"

# Color output (works on both Mac and Windows Git Bash)
# Basic colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'

# Enhanced colors for visual appeal
BOLD_RED='\033[1;31m'
BOLD_GREEN='\033[1;32m'
BOLD_YELLOW='\033[1;33m'
BOLD_BLUE='\033[1;34m'
BOLD_CYAN='\033[1;36m'
BOLD_MAGENTA='\033[1;35m'
BOLD_WHITE='\033[1;37m'

# Bright colors for extra vibrancy
BRIGHT_GREEN='\033[1;92m'
BRIGHT_BLUE='\033[1;94m'
BRIGHT_CYAN='\033[1;96m'
BRIGHT_MAGENTA='\033[1;95m'
BRIGHT_YELLOW='\033[1;93m'

# Standard colors for variety
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'

# Dim colors for subtle text
DIM='\033[2m'

NC='\033[0m' # No Color

print_usage() {
    echo "Usage: branch-clone [SOURCE] [BRANCH_NAME] [--claude [CLAUDE_ARGS...]]"
    echo ""
    echo "SOURCE can be:"
    echo "  .                 - Current directory (must be a git repo)"
    echo "  <git-url>         - Any valid git URL"
    echo ""
    echo "BRANCH_NAME: The branch to checkout or create"
    echo ""
    echo "This script uses git worktrees for efficient branch management."
    echo "Each branch gets its own directory but shares the git database."
    echo ""
    echo "Options:"
    echo "  --install         Install this script globally"
    echo "  --version         Show version"
    echo "  --help            Show this help message"
    echo "  --claude [ARGS]   After setup, launch Claude Code with specified args"
    echo ""
    echo "Examples:"
    echo "  branch-clone . feature-auth"
    echo "  branch-clone https://github.com/user/repo.git feature-auth"
    echo "  branch-clone . bugfix --claude \"fix the authentication bug\""
    echo "  branch-clone . feature --claude --continue"
}

print_error() {
    echo -e "${BOLD_RED}✗ Error: $1${NC}" >&2
}

print_success() {
    echo -e "${BRIGHT_GREEN}✓ $1${NC}"
}

print_info() {
    echo -e "${BRIGHT_CYAN}ℹ $1${NC}"
}

print_warning() {
    echo -e "${BRIGHT_YELLOW}⚠ $1${NC}"
}

print_header() {
    echo -e "${BOLD_MAGENTA}$1${NC}"
}

print_section() {
    echo -e "${BOLD_CYAN}━━━ $1${NC}"
}

print_highlight() {
    echo -e "${BRIGHT_MAGENTA}★ $1${NC}"
}

# Verbose output (suppressed in --claude mode)
print_verbose() {
    if [ "$CLAUDE_MODE" = false ]; then
        echo -e "${CYAN}$1${NC}"
    fi
}

print_verbose_raw() {
    if [ "$CLAUDE_MODE" = false ]; then
        echo "$1"
    fi
}

print_verbose_success() {
    if [ "$CLAUDE_MODE" = false ]; then
        echo -e "${BRIGHT_GREEN}✓ $1${NC}"
    fi
}

print_verbose_section() {
    if [ "$CLAUDE_MODE" = false ]; then
        echo -e "${BOLD_CYAN}━━━ $1 ━━━${NC}"
    fi
}

install_globally() {
    print_info "Installing branch-clone globally..."

    # Determine the installation directory
    if [[ "$OSTYPE" == "darwin"* ]] || [[ "$OSTYPE" == "linux-gnu"* ]]; then
        # macOS or Linux
        INSTALL_DIR="/usr/local/bin"
        if [ ! -w "$INSTALL_DIR" ]; then
            print_warning "Requesting sudo access to install to $INSTALL_DIR"
            sudo cp "$0" "$INSTALL_DIR/branch-clone"
            sudo chmod +x "$INSTALL_DIR/branch-clone"
        else
            cp "$0" "$INSTALL_DIR/branch-clone"
            chmod +x "$INSTALL_DIR/branch-clone"
        fi
    else
        # Windows (Git Bash)
        INSTALL_DIR="$HOME/bin"
        mkdir -p "$INSTALL_DIR"
        cp "$0" "$INSTALL_DIR/branch-clone"
        chmod +x "$INSTALL_DIR/branch-clone"
        print_warning "Make sure $INSTALL_DIR is in your PATH"
    fi

    print_success "Successfully installed to $INSTALL_DIR/branch-clone"
    exit 0
}

# Parse command line arguments
if [ "$1" == "--install" ]; then
    install_globally
elif [ "$1" == "--version" ]; then
    echo "branch-clone version $VERSION"
    exit 0
elif [ "$1" == "--help" ] || [ $# -lt 2 ]; then
    print_usage
    exit 0
fi

SOURCE="$1"
BRANCH_NAME="$2"

# Parse for --claude flag and capture remaining args
CLAUDE_MODE=false
CLAUDE_ARGS=()
shift 2  # Remove SOURCE and BRANCH_NAME from $@

for arg in "$@"; do
    if [ "$arg" == "--claude" ]; then
        CLAUDE_MODE=true
        shift
        # Capture all remaining arguments for Claude
        CLAUDE_ARGS=("$@")
        break
    fi
    shift
done

# Print execution header (minimal if --claude mode)
if [ "$CLAUDE_MODE" = false ]; then
    echo ""
    echo -e "${BOLD_MAGENTA}╔═══════════════════════════════════════╗${NC}"
    echo -e "${BOLD_MAGENTA}║${NC}  ${BRIGHT_CYAN}branch-clone${NC} ${BOLD_WHITE}v$VERSION${NC}              ${BOLD_MAGENTA}║${NC}"
    echo -e "${BOLD_MAGENTA}╚═══════════════════════════════════════╝${NC}"
    echo ""
    print_section "EXECUTION CONTEXT"
    print_info "Command: ${BOLD_WHITE}branch-clone $SOURCE $BRANCH_NAME${NC}"
    print_info "Working directory: ${DIM}$PWD${NC}"
    print_info "Requested branch: ${BRIGHT_YELLOW}$BRANCH_NAME${NC}"
    echo ""
    print_section "WHAT THIS SCRIPT DOES"
    print_verbose "This script uses 'git worktree' to create isolated working directories"
    print_verbose "for different branches. Worktrees share the .git database but have"
    print_verbose "separate working files (code, node_modules, builds, etc.)."
    echo ""
else
    print_info "[branch-clone] Setting up worktree for branch: $BRANCH_NAME"
fi

# Validate branch name
if [[ ! "$BRANCH_NAME" =~ ^[a-zA-Z0-9/_-]+$ ]]; then
    print_error "Invalid branch name: $BRANCH_NAME"
    print_error "Branch names can only contain: a-z, A-Z, 0-9, /, _, -"
    exit 1
fi

# Determine if source is a URL or local path
is_git_url() {
    [[ "$1" =~ ^(https?://|git@|ssh://|git://) ]]
}

# Extract repo name from git URL
get_repo_name_from_url() {
    local url="$1"
    # Remove .git suffix
    url="${url%.git}"
    # Get last part of path
    basename "$url"
}

# Get the main worktree directory (handles if we're already in a worktree)
get_main_worktree() {
    # Get the path to the main .git directory
    local git_common_dir=$(git rev-parse --git-common-dir 2>/dev/null)
    if [ -z "$git_common_dir" ]; then
        return 1
    fi

    # Get the directory containing the main .git folder
    # This handles both regular repos and worktrees
    if [ -f "$git_common_dir/config" ]; then
        # This is the main .git directory
        dirname "$git_common_dir"
    else
        return 1
    fi
}

# Get base name for worktree (from main worktree directory)
get_base_name() {
    local main_worktree=$(get_main_worktree)
    if [ -z "$main_worktree" ]; then
        return 1
    fi
    basename "$main_worktree"
}

# Main logic
if [ "$SOURCE" == "." ]; then
    print_verbose_raw ""
    print_verbose_section "STEP 1: ANALYZING CURRENT REPOSITORY"
    print_verbose_raw ""
    print_verbose "Source mode: ${BRIGHT_MAGENTA}LOCAL DIRECTORY${NC} (current location)"

    # Verify current directory is a git repo
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        print_error "Current directory is not a git repository"
        print_error "You must be inside a git repository to use '.' as source"
        exit 1
    fi

    print_verbose_success "Current directory is a git repository"

    # Get the main worktree directory
    MAIN_WORKTREE=$(get_main_worktree)
    if [ -z "$MAIN_WORKTREE" ]; then
        print_error "Could not determine main worktree directory"
        exit 1
    fi

    # Check if we're in a worktree or main repo
    if [ "$PWD" == "$MAIN_WORKTREE" ]; then
        print_verbose "Status: You are in the ${BRIGHT_GREEN}MAIN repository${NC}"
    else
        print_verbose "Status: You are in a ${BRIGHT_YELLOW}WORKTREE${NC} (not the main repo)"
        print_verbose "The script will still work correctly - it will use the main repo"
    fi

    # Get base name and parent directory
    BASE_NAME=$(basename "$MAIN_WORKTREE")
    PARENT_DIR=$(dirname "$MAIN_WORKTREE")

    # Target directory
    TARGET_DIR="$PARENT_DIR/${BASE_NAME}-${BRANCH_NAME}"

    print_verbose_raw ""
    print_verbose "REPOSITORY STRUCTURE:"
    print_verbose "  Main repository:  ${DIM}$MAIN_WORKTREE${NC}"
    print_verbose "  Target worktree:  ${BRIGHT_CYAN}$TARGET_DIR${NC}"
    print_verbose "  Branch:           ${BRIGHT_YELLOW}$BRANCH_NAME${NC}"
    print_verbose_raw ""

    # Change to main worktree to run git worktree commands
    cd "$MAIN_WORKTREE"

    # Check if worktree already exists
    if [ -d "$TARGET_DIR" ]; then
        print_verbose "EXISTING WORKTREE FOUND"
        print_verbose "  Location: $TARGET_DIR"
        print_verbose "  Action: Will update existing worktree and ensure correct branch"
        print_verbose_raw ""
        cd "$TARGET_DIR"
        git fetch --all 2>&1 | ([ "$CLAUDE_MODE" = true ] && grep -v "^From" || cat)
        WORKTREE_ACTION="updated"
    else
        print_verbose "NEW WORKTREE NEEDED"
        print_verbose "  Will create new worktree at: $TARGET_DIR"
        print_verbose_raw ""
        # We'll handle branch creation/checkout below
        # For now just note we need to create the worktree
        NEED_CREATE_WORKTREE=true
        WORKTREE_ACTION="created"
    fi

elif is_git_url "$SOURCE"; then
    print_verbose_raw ""
    print_verbose_section "STEP 1: ANALYZING REMOTE REPOSITORY"
    print_verbose_raw ""
    print_verbose "Source mode: ${BRIGHT_MAGENTA}GIT URL${NC} (remote repository)"

    # Extract repo name
    REPO_NAME=$(get_repo_name_from_url "$SOURCE")

    # Main repository directory
    MAIN_REPO_DIR="$HOME/git/${REPO_NAME}"

    # Target directory in ~/git
    TARGET_DIR="$HOME/git/${REPO_NAME}-${BRANCH_NAME}"

    print_verbose "Git URL:      ${DIM}$SOURCE${NC}"
    print_verbose "Repository:   ${BRIGHT_CYAN}$REPO_NAME${NC}"
    print_verbose_raw ""
    print_verbose "REPOSITORY STRUCTURE:"
    print_verbose "  Main repository:  ${DIM}$MAIN_REPO_DIR${NC}"
    print_verbose "  Target worktree:  ${BRIGHT_CYAN}$TARGET_DIR${NC}"
    print_verbose "  Branch:           ${BRIGHT_YELLOW}$BRANCH_NAME${NC}"
    print_verbose_raw ""

    # Create ~/git if it doesn't exist
    mkdir -p "$HOME/git"

    # Check if main repo exists, if not clone it
    if [ ! -d "$MAIN_REPO_DIR" ]; then
        print_verbose "MAIN REPOSITORY NOT FOUND LOCALLY"
        print_verbose "  This is the first time accessing this repository"
        print_verbose "  Action: ${BRIGHT_YELLOW}Cloning main repository from remote...${NC}"
        print_verbose_raw ""
        if [ "$CLAUDE_MODE" = true ]; then
            git clone "$SOURCE" "$MAIN_REPO_DIR" 2>&1 | grep -E "(Cloning|Receiving|Resolving)" || true
        else
            git clone "$SOURCE" "$MAIN_REPO_DIR"
        fi
        print_verbose_success "Main repository cloned to $MAIN_REPO_DIR"
        print_verbose_raw ""
        REPO_ACTION="cloned"
    else
        print_verbose_success "Main repository already exists locally"
        print_verbose "  Location: ${DIM}$MAIN_REPO_DIR${NC}"
        print_verbose_raw ""
        REPO_ACTION="existing"
    fi

    # Change to main repo
    cd "$MAIN_REPO_DIR"

    # Fetch latest from remote
    print_verbose "Fetching latest changes from remote..."
    if [ "$CLAUDE_MODE" = true ]; then
        git fetch --all 2>&1 | grep -v "^From" || true
    else
        git fetch --all
    fi
    print_verbose_success "Repository is up to date"
    print_verbose_raw ""

    # Check if worktree already exists
    if [ -d "$TARGET_DIR" ]; then
        print_verbose "EXISTING WORKTREE FOUND"
        print_verbose "  Location: $TARGET_DIR"
        print_verbose "  Action: Will update existing worktree and ensure correct branch"
        print_verbose_raw ""
        cd "$TARGET_DIR"
        if [ "$CLAUDE_MODE" = true ]; then
            git fetch --all 2>&1 | grep -v "^From" || true
        else
            git fetch --all
        fi
        WORKTREE_ACTION="updated"
    else
        print_verbose "NEW WORKTREE NEEDED"
        print_verbose "  Will create new worktree at: $TARGET_DIR"
        print_verbose_raw ""
        NEED_CREATE_WORKTREE=true
        WORKTREE_ACTION="created"
    fi

else
    print_error "Invalid source: $SOURCE"
    print_error "Source must be '.' for current directory or a valid Git URL"
    exit 1
fi

# Handle branch and worktree creation
print_verbose_raw ""
print_verbose_section "STEP 2: HANDLING BRANCH AND WORKTREE"
print_verbose_raw ""

if [ "$NEED_CREATE_WORKTREE" = true ]; then
    # Check if branch exists locally
    if git show-ref --verify --quiet "refs/heads/$BRANCH_NAME"; then
        print_verbose_success "Branch '${BRIGHT_YELLOW}$BRANCH_NAME${NC}' exists LOCALLY"
        print_verbose "  Action: ${BRIGHT_CYAN}Creating worktree from local branch${NC}"
        print_verbose_raw ""
        if [ "$CLAUDE_MODE" = true ]; then
            git worktree add "$TARGET_DIR" "$BRANCH_NAME" 2>&1 | grep -E "(Preparing|Updating)" || true
        else
            git worktree add "$TARGET_DIR" "$BRANCH_NAME"
        fi
        cd "$TARGET_DIR"
        print_verbose "  Pulling latest changes from remote..."
        git pull origin "$BRANCH_NAME" 2>/dev/null || print_verbose "Could not pull from origin (branch may not exist remotely yet)"
        BRANCH_ACTION="existing-local"

    # Check if branch exists remotely
    elif git show-ref --verify --quiet "refs/remotes/origin/$BRANCH_NAME"; then
        print_verbose_success "Branch '${BRIGHT_YELLOW}$BRANCH_NAME${NC}' exists REMOTELY (not local yet)"
        print_verbose "  Action: ${BRIGHT_CYAN}Creating worktree and checking out remote branch${NC}"
        print_verbose_raw ""
        if [ "$CLAUDE_MODE" = true ]; then
            git worktree add "$TARGET_DIR" "$BRANCH_NAME" 2>&1 | grep -E "(Preparing|Updating)" || true
        else
            git worktree add "$TARGET_DIR" "$BRANCH_NAME"
        fi
        cd "$TARGET_DIR"
        BRANCH_ACTION="existing-remote"

    # Branch doesn't exist anywhere, create it
    else
        print_verbose "Branch '${BRIGHT_YELLOW}$BRANCH_NAME${NC}' ${BRIGHT_MAGENTA}DOES NOT EXIST${NC}"
        print_verbose "  Action: ${BRIGHT_GREEN}Creating new branch${NC}"

        # Determine base branch (prefer main, fallback to master)
        if git show-ref --verify --quiet "refs/heads/main"; then
            BASE_BRANCH="main"
        elif git show-ref --verify --quiet "refs/heads/master"; then
            BASE_BRANCH="master"
        elif git show-ref --verify --quiet "refs/remotes/origin/main"; then
            BASE_BRANCH="origin/main"
        elif git show-ref --verify --quiet "refs/remotes/origin/master"; then
            BASE_BRANCH="origin/master"
        else
            BASE_BRANCH=$(git rev-parse --abbrev-ref HEAD)
        fi

        print_verbose "  Base branch:  ${BRIGHT_CYAN}$BASE_BRANCH${NC}"
        print_verbose_raw ""
        if [ "$CLAUDE_MODE" = true ]; then
            git worktree add -b "$BRANCH_NAME" "$TARGET_DIR" "$BASE_BRANCH" 2>&1 | grep -E "(Preparing|Updating)" || true
        else
            git worktree add -b "$BRANCH_NAME" "$TARGET_DIR" "$BASE_BRANCH"
        fi
        cd "$TARGET_DIR"

        # Push and set up tracking
        print_verbose "  Pushing new branch to remote and setting up tracking..."
        if git push -u origin "$BRANCH_NAME" 2>/dev/null; then
            print_verbose_success "Branch pushed to remote and tracking configured"
            BRANCH_ACTION="created-and-pushed"
        else
            print_verbose "  ${BRIGHT_YELLOW}Could not push to remote (you may need to push manually later)${NC}"
            BRANCH_ACTION="created-local-only"
        fi
    fi
else
    # Worktree already existed, just make sure we're on the right branch
    print_verbose "Worktree already exists - ${BRIGHT_CYAN}updating...${NC}"
    CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
    if [ "$CURRENT_BRANCH" != "$BRANCH_NAME" ]; then
        print_verbose "  Current branch: ${BRIGHT_MAGENTA}$CURRENT_BRANCH${NC} (expected: ${BRIGHT_YELLOW}$BRANCH_NAME${NC})"
        print_verbose "  Action: Switching to ${BRIGHT_YELLOW}$BRANCH_NAME${NC}..."
        git checkout "$BRANCH_NAME" 2>&1 | ([ "$CLAUDE_MODE" = true ] && grep -v "^Switched" || cat)
        print_verbose_success "Switched to $BRANCH_NAME"
    else
        print_verbose_success "Already on correct branch: $BRANCH_NAME"
    fi
    print_verbose_raw ""
    print_verbose "  Pulling latest changes..."
    if git pull origin "$BRANCH_NAME" 2>/dev/null; then
        print_verbose_success "Updated from remote"
    else
        print_verbose "  ${DIM}Could not pull from origin (this may be okay)${NC}"
    fi
    BRANCH_ACTION="updated"
fi

echo ""

# Summary (comprehensive if not --claude mode, minimal if --claude mode)
if [ "$CLAUDE_MODE" = false ]; then
    # Comprehensive summary
    echo -e "${BOLD_MAGENTA}╔═══════════════════════════════════════╗${NC}"
    echo -e "${BOLD_MAGENTA}║${NC}  ${BRIGHT_GREEN}✓ EXECUTION COMPLETE - SUMMARY${NC}    ${BOLD_MAGENTA}║${NC}"
    echo -e "${BOLD_MAGENTA}╚═══════════════════════════════════════╝${NC}"
    echo ""

    print_section "WHAT HAPPENED"
    if [ -n "$REPO_ACTION" ]; then
        if [ "$REPO_ACTION" == "cloned" ]; then
            print_highlight "Main repository was cloned from remote URL"
        else
            print_info "Main repository already existed locally"
        fi
    fi

    case "$WORKTREE_ACTION" in
        "created")
            print_highlight "New worktree was created"
            ;;
        "updated")
            print_info "Existing worktree was updated"
            ;;
    esac

    case "$BRANCH_ACTION" in
        "existing-local")
            print_info "Branch existed locally and was checked out"
            ;;
        "existing-remote")
            print_info "Branch existed remotely and was checked out"
            ;;
        "created-and-pushed")
            print_highlight "NEW branch was created and pushed to remote"
            ;;
        "created-local-only")
            print_warning "NEW branch was created (local only, not yet pushed)"
            ;;
        "updated")
            print_info "Branch was already checked out and updated"
            ;;
    esac

    echo ""
    print_section "CURRENT STATE"
    print_success "Working directory:  ${BOLD_WHITE}$PWD${NC}"
    print_success "Current branch:     ${BRIGHT_YELLOW}$(git rev-parse --abbrev-ref HEAD)${NC}"
    print_success "Latest commit:      ${DIM}$(git log -1 --oneline)${NC}"
    echo ""

    print_section "IMPORTANT NOTES"
    print_warning "This is a GIT WORKTREE (not a clone)"
    print_info "  ${CYAN}→${NC} Shares .git database with main repository"
    print_info "  ${CYAN}→${NC} Separate working files (code, node_modules, builds, etc.)"
    print_info "  ${CYAN}→${NC} Changes to tracked files affect the shared git database"
    echo ""

    print_section "NEXT STEPS YOU MAY NEED"
    print_info "${BRIGHT_CYAN}1.${NC} Install dependencies:      ${BOLD_WHITE}npm install${NC}  (or yarn/pnpm)"
    print_info "${BRIGHT_CYAN}2.${NC} Copy environment files:    ${BOLD_WHITE}cp ../.env .env${NC}  (if needed)"
    print_info "${BRIGHT_CYAN}3.${NC} Build the project:         ${BOLD_WHITE}npm run build${NC}  (if needed)"
    echo ""

    print_section "NAVIGATION"
    echo -e "  ${CYAN}→${NC} To return to this worktree: ${BOLD_WHITE}cd $PWD${NC}"
    if [ -n "$MAIN_WORKTREE" ]; then
        echo -e "  ${CYAN}→${NC} Main repository location:   ${BOLD_WHITE}cd $MAIN_WORKTREE${NC}"
    elif [ -n "$MAIN_REPO_DIR" ]; then
        echo -e "  ${CYAN}→${NC} Main repository location:   ${BOLD_WHITE}cd $MAIN_REPO_DIR${NC}"
    fi
    echo ""

    print_section "WORKTREE MANAGEMENT"
    echo -e "  ${CYAN}→${NC} List all worktrees:         ${BOLD_WHITE}git worktree list${NC}"
    echo -e "  ${CYAN}→${NC} Remove this worktree:       ${BOLD_WHITE}git worktree remove $PWD${NC}"
    echo ""

    echo -e "${BOLD_GREEN}╔═══════════════════════════════════════╗${NC}"
    echo -e "${BOLD_GREEN}║${NC}  ${BRIGHT_YELLOW}★${NC} Ready to work on: ${BRIGHT_YELLOW}$BRANCH_NAME${NC}     ${BOLD_GREEN}║${NC}"
    echo -e "${BOLD_GREEN}╚═══════════════════════════════════════╝${NC}"
    echo ""
else
    # Minimal summary for --claude mode
    print_info "[branch-clone] ✓ Worktree ready"
    print_info "[branch-clone]   Directory: $PWD"
    print_info "[branch-clone]   Branch: $(git rev-parse --abbrev-ref HEAD)"

    # Check if claude CLI exists
    if ! command -v claude &> /dev/null; then
        echo ""
        print_error "[branch-clone] Claude CLI not found in PATH"
        print_error "[branch-clone] Please install Claude Code CLI first"
        print_error "[branch-clone] See: https://docs.anthropic.com/claude/docs/claude-cli"
        exit 1
    fi

    print_info "[branch-clone] Launching Claude Code..."
    echo ""

    # Use exec to replace this process with Claude Code
    # This makes output stream naturally and preserves exit code
    exec claude "${CLAUDE_ARGS[@]}"
fi
